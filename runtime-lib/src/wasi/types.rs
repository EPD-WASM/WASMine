/// Wasm pointer type
#[repr(transparent)]
pub struct Ptr<T>(u32, std::marker::PhantomData<T>);

/// Wasm constant pointer type
pub type ConstPtr = u32;

/// Type of a subscription to an event or its occurrence.
#[repr(u8)]
pub enum EventType {
    /// The time value of clock `subscription_clock::id` has reached timestamp `subscription_clock::timeout`.
    Clock = 0,
    /// File descriptor `subscription_fd_readwrite::file_descriptor` has data available for reading. This event always triggers for regular files.
    FdRead = 1,
    /// File descriptor `subscription_fd_readwrite::file_descriptor` has capacity available for writing. This event always triggers for regular files.
    FdWrite = 2,
}

/// The state of the file descriptor subscribed to with `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub struct EventRwFlags {
    /// The peer of this socket has closed or disconnected.
    pub fd_readwrite_hangup: bool,
}

/// The contents of an `event` when type is `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub struct EventFdReadwrite {
    /// The number of bytes available for reading or writing.
    pub nbytes: FileSize,
    /// The state of the file descriptor.
    pub flags: EventRwFlags,
}

/// An event that occurred.
#[repr(C)]
pub struct Event {
    /// User-provided value that got attached to `subscription::userdata`.
    pub userdata: UserData,
    /// If non-zero, an error that occurred while processing the subscription request.
    pub error: Errno,
    /// The type of event that occured
    pub type_: EventType,
    /// The contents of the event, if it is an `eventtype::fd_read` or `eventtype::fd_write`. `eventtype::clock` events ignore this field.
    pub fd_readwrite: EventFdReadwrite,
}

/// Flags determining how to interpret the timestamp provided in `subscription_clock::timeout`.
#[repr(C)]
pub struct SubClockFlags {
    /// If set, treat the timestamp provided in `subscription_clock::timeout` as an absolute timestamp of clock `subscription_clock::id`. If clear, treat the timestamp provided in `subscription_clock::timeout` relative to the current time value of clock `subscription_clock::id`.
    pub subscription_clock_abstime: bool,
}

/// The contents of a `subscription` when type is `eventtype::clock`.
#[repr(C)]
pub struct SubscriptionClock {
    /// The clock against which to compare the timestamp.
    pub id: ClockID,
    /// The absolute or relative timestamp.
    pub timeout: TimeStamp,
    /// The amount of time that the implementation may wait additionally to coalesce with other events.
    pub precision: TimeStamp,
    /// Flags specifying whether the timeout is absolute or relative
    pub flags: SubClockFlags,
}

/// The contents of a `subscription` when type is type is `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub struct SubscriptionFdReadwrite {
    /// The file descriptor on which to wait for it to become ready for reading or writing.
    pub file_descriptor: FD,
}

/// The contents of a `subscription`.
#[repr(u8)]
pub enum SubscriptionU {
    Clock(SubscriptionClock),
    FdRead(SubscriptionFdReadwrite),
    FdWrite(SubscriptionFdReadwrite),
}

/// Subscription to an event.
#[repr(C)]
pub struct Subscription {
    /// User-provided value that is attached to the subscription in the implementation and returned through `event::userdata`.
    pub userdata: UserData,
    /// The type of the event to which to subscribe, and its contents
    pub u: SubscriptionU,
}

/// Exit code generated by a process when exiting.
pub type ExitCode = u32;

/// Signal condition.
#[repr(u8)]
pub enum Signal {
    /// No signal. Note that POSIX has special semantics for `kill(pid, 0)`, so this value is reserved.
    None = 0,
    /// Hangup.
    /// Action: Terminates the process.
    Hup = 1,
    /// Terminate interrupt signal.
    /// Action: Terminates the process.
    Int = 2,
    /// Terminal quit signal.
    /// Action: Terminates the process.
    Quit = 3,
    /// Illegal instruction.
    /// Action: Terminates the process.
    Ill = 4,
    /// Trace/breakpoint trap.
    /// Action: Terminates the process.
    Trap = 5,
    /// Process abort signal.
    /// Action: Terminates the process.
    Abrt = 6,
    /// Access to an undefined portion of a memory object.
    /// Action: Terminates the process.
    Bus = 7,
    /// Erroneous arithmetic operation.
    /// Action: Terminates the process.
    Fpe = 8,
    /// Kill.
    /// Action: Terminates the process.
    Kill = 9,
    /// User-defined signal 1.
    /// Action: Terminates the process.
    Usr1 = 10,
    /// Invalid memory reference.
    /// Action: Terminates the process.
    Segv = 11,
    /// User-defined signal 2.
    /// Action: Terminates the process.
    Usr2 = 12,
    /// Write on a pipe with no one to read it.
    /// Action: Ignored.
    Pipe = 13,
    /// Alarm clock.
    /// Action: Terminates the process.
    Alrm = 14,
    /// Termination signal.
    /// Action: Terminates the process.
    Term = 15,
    /// Child process terminated, stopped, or continued.
    /// Action: Ignored.
    Chld = 16,
    /// Continue executing, if stopped.
    /// Action: Continues executing, if stopped.
    Cont = 17,
    /// Stop executing.
    /// Action: Stops executing.
    Stop = 18,
    /// Terminal stop signal.
    /// Action: Stops executing.
    Tstp = 19,
    /// Background process attempting read.
    /// Action: Stops executing.
    Ttin = 20,
    /// Background process attempting write.
    /// Action: Stops executing.
    Ttou = 21,
    /// High bandwidth data is available at a socket.
    /// Action: Ignored.
    Urg = 22,
    /// CPU time limit exceeded.
    /// Action: Terminates the process.
    Xcpu = 23,
    /// File size limit exceeded.
    /// Action: Terminates the process.
    Xfsz = 24,
    /// Virtual timer expired.
    /// Action: Terminates the process.
    Vtalrm = 25,
    /// Profiling timer expired.
    /// Action: Terminates the process.
    Prof = 26,
    /// Window changed.
    /// Action: Ignored.
    Winch = 27,
    /// I/O possible.
    /// Action: Terminates the process.
    Poll = 28,
    /// Power failure.
    /// Action: Terminates the process.
    Pwr = 29,
    /// Bad system call.
    /// Action: Terminates the process.
    Sys = 30,
}

/// Flags provided to `sock_recv`.
#[repr(C)]
pub struct RiFlags {
    /// Returns the message without removing it from the socket's receive queue.
    pub recv_peek: bool,
    /// On byte-stream sockets, block until the full amount of data can be returned.
    pub recv_waitall: bool,
}

/// Flags returned by `sock_recv`.
#[repr(C)]
pub struct RoFlags {
    /// Returned by `sock_recv`: Message data has been truncated.
    pub recv_data_truncated: bool,
}

/// Flags provided to `sock_shutdown`. As there are currently no flags defined, it must be set to zero.
pub type SiFlags = u16;

/// Which channels on a socket to shut down.
#[repr(u8)]
pub enum SdFlags {
    /// Disables further receive operations.
    Rd = 1 << 0,
    /// Disables further send operations.
    Wr = 1 << 1,
}

/// Identifier for preopened capabilities.
#[repr(u8)]
pub enum PreopenType {
    /// A pre-opened directory.
    Dir = 0,
}

/// The contents of a `prestat` when type is `preopen_type::dir`.
#[repr(C)]
pub struct PreStatDir {
    /// The length of the directory name for use with `fd_prestat_dir_name`.
    pub pr_name_len: Size,
}

/// Information about a pre-opened directory.
#[repr(u8)]
pub enum PreStat {
    Dir(PreStatDir),
}

/// Result type
#[repr(u32)]
pub enum Result<R, E> {
    Ok(R),
    Err(E),
}

pub type Size = u32;
pub type FileSize = u64;
pub type TimeStamp = u64;

#[repr(u32)]
pub enum ClockID {
    Realtime = 0,
    Monotonic = 1,
    ProcessCputimeID = 2,
    ThreadCputimeID = 3,
}

/// Error codes returned by functions. Not all of these error codes are returned by the functions provided by this API;
/// some are used in higher-level library layers, and others are provided merely for alignment with POSIX.
#[repr(u16)]
pub enum Errno {
    /// Success
    Success = 0,
    /// Argument list too long
    TooBig = 1,
    /// Permission denied
    Access = 2,
    /// Address already in use
    AddrInUse = 3,
    /// Cannot assign requested address
    AddrNotAvail = 4,
    /// Address family not supported by protocol
    AfNoSupport = 5,
    /// Resource temporarily unavailable
    Again = 6,
    /// Operation already in progress
    Already = 7,
    /// Bad file descriptor
    Badf = 8,
    /// Bad message
    BadMsg = 9,
    /// Device or resource busy
    Busy = 10,
    /// Operation canceled
    Canceled = 11,
    /// No child processes
    Child = 12,
    /// Connection aborted
    ConnAborted = 13,
    /// Connection refused
    ConnRefused = 14,
    /// Connection reset by peer
    ConnReset = 15,
    /// Resource deadlock would occur
    Deadlk = 16,
    /// Destination address required
    DestAddrReq = 17,
    /// Mathematics argument out of domain of function
    Dom = 18,
    /// Reserved
    Dquot = 19,
    /// File exists
    Exist = 20,
    /// Bad address
    Fault = 21,
    /// File too large
    FBig = 22,
    /// Host is unreachable
    HostUnreach = 23,
    /// Identifier removed
    Idrm = 24,
    /// Illegal byte sequence
    Ilseq = 25,
    /// Operation in progress
    InProgress = 26,
    /// Interrupted system call
    Intr = 27,
    /// Invalid argument
    Inval = 28,
    /// I/O error
    Io = 29,
    /// Socket is connected
    IsConn = 30,
    /// Is a directory
    IsDir = 31,
    /// Too many levels of symbolic links
    Loop = 32,
    /// File descriptor value too large
    MFile = 33,
    /// Too many links
    MLink = 34,
    /// Message too large
    MsgSize = 35,
    /// Reserved
    MultiHop = 36,
    /// File name too long
    NameTooLong = 37,
    /// Network is down
    NetDown = 38,
    /// Connection aborted by network
    NetReset = 39,
    /// Network unreachable
    NetUnreach = 40,
    /// Too many open files in system
    NFile = 41,
    /// No buffer space available
    NoBufs = 42,
    /// No such device
    NoDev = 43,
    /// No such file or directory
    NoEnt = 44,
    /// Executable file format error
    NoExec = 45,
    /// No locks available
    NoLck = 46,
    /// Reserved
    NoLink = 47,
    /// Not enough memory
    NoMem = 48,
    /// No message of the desired type
    NoMsg = 49,
    /// Protocol not available
    NoProtoOpt = 50,
    /// No space left on device
    NoSpace = 51,
    /// Function not implemented
    NoSys = 52,
    /// Not connected
    NotConn = 53,
    /// Not a directory
    NotDir = 54,
    /// Directory not empty
    NotEmpty = 55,
    /// State not recoverable
    NotRecoverable = 56,
    /// Not a socket
    NotSock = 57,
    /// Not supported
    NotSup = 58,
    /// Inappropriate I/O control operation
    NotTy = 59,
    /// No such device or address
    Nxio = 60,
    /// Value too large to be stored in data type
    Overflow = 61,
    /// Previous owner died
    OwnerDead = 62,
    /// Operation not permitted
    Perm = 63,
    /// Broken pipe
    Pipe = 64,
    /// Protocol error
    Proto = 65,
    /// Protocol not supported
    ProtoNoSupport = 66,
    /// Protocol wrong type for socket
    Prototype = 67,
    /// Math result not representable
    Range = 68,
    /// Read-only file system
    Rofs = 69,
    /// Streams pipe error
    Spipe = 70,
    /// No such process
    Srch = 71,
    /// Stale file handle
    Stale = 72,
    /// Connection timed out
    TimedOut = 73,
    /// Text file busy
    TxtBsy = 74,
    /// Cross-device link
    Xdev = 75,
    /// Operation not supported on transport endpoint
    NotCapable = 76,
}

/// File descriptor.
pub type FD = u32;

/// File descriptor rights, determining which actions may be performed.
#[repr(u64)]
pub enum Rights {
    /// The right to invoke `fd_datasync`. If `path_open` is set, includes the right to invoke `path_open` with `fdflags::dsync`.
    FdDatasync = 1 << 0,
    /// The right to invoke `fd_read` and `sock_recv`. If `rights::fd_seek` is set, includes the right to invoke `fd_pread`.
    FdRead = 1 << 1,
    /// The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.
    FdSeek = 1 << 2,
    /// The right to invoke `fd_fdstat_set_flags`.
    FdFdstatSetFlags = 1 << 3,
    /// The right to invoke `fd_sync`. If `path_open` is set, includes the right to invoke `path_open` with `fdflags::rsync` and `fdflags::dsync`.
    FdSync = 1 << 4,
    /// The right to invoke `fd_tell` in such a way that the file offset remains unaltered (i.e., `whence::cur` with offset zero), or to invoke `fd_tell`.
    FdTell = 1 << 5,
    /// The right to invoke `fd_write` and `sock_send`. If `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.
    FdWrite = 1 << 6,
    /// The right to invoke `fd_advise`.
    FdAdvise = 1 << 7,
    /// The right to invoke `fd_allocate`.
    FdAllocate = 1 << 8,
    /// The right to invoke `path_create_directory`.
    PathCreateDirectory = 1 << 9,
    /// The right to invoke `path_create_file`. If `path_open` is set, the right to invoke `path_open` with `oflags::creat`.
    PathCreateFile = 1 << 10,
    /// The right to invoke `path_link` with the file descriptor as the source directory.
    PathLinkSource = 1 << 11,
    /// The right to invoke `path_link` with the file descriptor as the target directory.
    PathLinkTarget = 1 << 12,
    /// The right to invoke `path_open`.
    PathOpen = 1 << 13,
    /// The right to invoke `fd_readdir`.
    FdReaddir = 1 << 14,
    /// The right to invoke `path_readlink`.
    PathReadlink = 1 << 15,
    /// The right to invoke `path_rename` with the file descriptor as the source directory.
    PathRenameSource = 1 << 16,
    /// The right to invoke `path_rename` with the file descriptor as the target directory.
    PathRenameTarget = 1 << 17,
    /// The right to invoke `path_filestat_get`.
    PathFilestatGet = 1 << 18,
    /// The right to change a file's size. If `path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.
    PathFilestatSetSize = 1 << 19,
    /// The right to invoke `path_filestat_set_times`.
    PathFilestatSetTimes = 1 << 20,
    /// The right to invoke `fd_filestat_get`.
    FdFilestatGet = 1 << 21,
    /// The right to invoke `fd_filestat_set_size`.
    FdFilestatSetSize = 1 << 22,
    /// The right to invoke `fd_filestat_set_times`.
    FdFilestatSetTimes = 1 << 23,
    /// The right to invoke `path_symlink`.
    PathSymlink = 1 << 24,
    /// The right to invoke `path_remove_directory`.
    PathRemoveDirectory = 1 << 25,
    /// The right to invoke `path_unlink_file`.
    PathUnlinkFile = 1 << 26,
    /// If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`. If `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.
    PollFdReadwrite = 1 << 27,
    /// The right to invoke `sock_shutdown`.
    SockShutdown = 1 << 28,
    /// The right to invoke `sock_accept`.
    SockAccept = 1 << 29,
}

/// A region of memory for scatter/gather reads.
#[repr(C)]
pub struct IOVec {
    /// The address of the buffer to be filled.
    buf: Ptr<()>,
    /// The length of the buffer to be filled.
    buf_len: Size,
}

/// A region of memory for scatter/gather reads.
#[repr(C)]
pub struct CIOVec {
    /// The address of the buffer to be filled.
    buf: ConstPtr,
    /// The length of the buffer to be filled.
    buf_len: Size,
}

/// List of scatter/gather vectors.
pub type IOVecArray<'a> = &'a [IOVec];

/// List of constant scatter/gather vectors.
pub type CIOVecArray<'a> = &'a [CIOVec];

/// Relative offset within a file.
pub type FileDelta = i64;

/// The position relative to which to set the offset of the file descriptor.
#[repr(u8)]
pub enum Whence {
    Set = 0,
    Cur = 1,
    End = 2,
}

/// A reference to the offset of a directory entry.
/// The value 0 signifies the start of the directory.
pub type DirCookie = u64;

/// The type for the `dirent::d_namlen` field of `dirent` struct.
pub type DirNamLen = u32;

/// File serial number that is unique within its file system.
pub type INode = u64;

/// The type of a file descriptor or file.
pub enum FileType {
    /// The type of the file descriptor or file is unknown or is different from any of the other types specified.
    Unknown = 0,
    /// The file descriptor or file refers to a block device inode.
    BlockDevice = 1,
    /// The file descriptor or file refers to a character device inode.
    CharacterDevice = 2,
    /// The file descriptor or file refers to a directory inode.
    Directory = 3,
    /// The file descriptor or file refers to a regular file inode.
    RegularFile = 4,
    /// The file descriptor or file refers to a datagram socket.
    SocketDgram = 5,
    /// The file descriptor or file refers to a byte-stream socket.
    SocketStream = 6,
    /// The file refers to a symbolic link inode.
    SymbolicLink = 7,
}

/// A directory entry.
#[repr(C)]
pub struct DirEnt {
    /// The offset of the next directory entry stored in the directory.
    pub d_next: DirCookie,
    /// The serial number of the file in the directory.
    pub d_ino: INode,
    /// The length of the name of the directory entry.
    pub d_namelen: DirNamLen,
    /// The type of the file.
    pub d_type: FileType,
}

/// File or memory access pattern advisory information.
#[repr(u8)]
pub enum Advice {
    /// The application has no further expectation about the access pattern of the specified data.
    Normal = 0,
    /// The application expects to access the specified data sequentially from lower offsets to higher offsets.
    Sequential = 1,
    /// The application expects to access the specified data in a random order.
    Random = 2,
    /// The application expects to access the specified data in the near future.
    WillNeed = 3,
    /// The application expects that it will not access the specified data in the near future.
    DontNeed = 4,
    /// The application expects to access the specified data once and then not reuse it thereafter.
    NoReuse = 5,
}

/// File descriptor flags.
#[repr(u16)]
pub enum FdFlags {
    /// Append mode: Data written to the file is always appended to the file's end.
    Append = 1 << 0,
    /// Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
    DSync = 1 << 1,
    /// Non-blocking mode.
    Nonblock = 1 << 2,
    /// Synchronized read I/O operations.
    RSync = 1 << 3,
    /// Synchronized write I/O operations.
    Sync = 1 << 4,
}

/// File descriptor attributes.
#[repr(C)]
pub struct FdStat {
    /// File type.
    pub fs_filetype: FileType,
    /// File descriptor flags.
    pub fs_flags: FdFlags,
    /// Rights that apply to this file descriptor.
    pub fs_rights_base: Rights,
    /// Maximum set of rights that may be installed on new paths relative to this file descriptor.
    pub fs_rights_inheriting: Rights,
}

/// Identifier for a device containing a file system.
pub type Device = u64;

/// Which file time attributes to adjust.
#[repr(u16)]
pub enum FstFlags {
    /// Adjust the last data access timestamp to the value stored in `filestat::atim`.
    Atim = 1 << 0,
    /// Adjust the last data access timestamp to the time of clock `clockid::realtime`.
    AtimNow = 1 << 1,
    /// Adjust the last data modification timestamp to the value stored in `filestat::mtim`.
    Mtim = 1 << 2,
    /// Adjust the last data modification timestamp to the time of clock `clockid::realtime`.
    MtimNow = 1 << 3,
}

/// Flags determining the method of how paths are resolved.
#[repr(u32)]
pub enum LookupFlags {
    /// As long as the resolved path corresponds to a symbolic link, it is expanded.
    SymlinkFollow = 1 << 0,
}

/// Open flags used by `path_open`.
#[repr(u16)]
pub enum OpenFlags {
    /// Create the file if it does not exist.
    Creat = 1 << 0,
    /// Fail if not a directory.
    Directory = 1 << 1,
    /// Fail if file already exists.
    Excl = 1 << 2,
    /// Truncate file to size 0.
    Trunc = 1 << 3,
}

/// Number of hard links to an inode.
pub type LinkCount = u32;

/// File attributes.
#[repr(C)]
pub struct FileStat {
    /// Device ID of device containing the file.
    pub dev: Device,
    /// File serial number.
    pub ino: INode,
    /// File type.
    pub filetype: FileType,
    /// Number of hard links to the file.
    pub nlink: LinkCount,
    /// For resizable files, the file size in bytes.
    /// For symbolic links, the length in bytes of the pathname contained in the symbolic link.
    pub size: FileSize,
    /// Last data access timestamp.
    pub atim: TimeStamp,
    /// Last data modification timestamp.
    pub mtim: TimeStamp,
    /// Last file status change timestamp.
    pub ctim: TimeStamp,

    _padding: [u8; 8],
}

/// User-provided value that may be attached to objects that is retained when extracted from the implementation.
pub type UserData = u64;
