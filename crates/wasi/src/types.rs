#![allow(dead_code)] // we have a lot of definition here that are not used yet

use bitflags::bitflags;
use module::objects::value::{Value, ValueRaw};
use std::os::unix::fs::FileTypeExt;

/// Wasm pointer type
#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub(crate) struct Ptr<T>(u32, std::marker::PhantomData<T>);

impl<T> Ptr<T> {
    pub(crate) fn get(&self) -> u32 {
        self.0
    }

    pub(crate) fn offset(&self, offset: u32) -> Self {
        Ptr(self.0 + offset, std::marker::PhantomData)
    }
}

impl<T> From<u32> for Ptr<T> {
    fn from(val: u32) -> Self {
        Ptr(val, std::marker::PhantomData)
    }
}
impl<T> From<ValueRaw> for Ptr<T> {
    fn from(val: ValueRaw) -> Self {
        Ptr(val.as_u32(), std::marker::PhantomData)
    }
}

/// Wasm constant pointer type
pub(crate) type ConstPtr = Ptr<u8>;

/// Type of a subscription to an event or its occurrence.
#[repr(u8)]
pub(crate) enum EventType {
    /// The time value of clock `subscription_clock::id` has reached timestamp `subscription_clock::timeout`.
    Clock = 0,
    /// File descriptor `subscription_fd_readwrite::file_descriptor` has data available for reading. This event always triggers for regular files.
    FdRead = 1,
    /// File descriptor `subscription_fd_readwrite::file_descriptor` has capacity available for writing. This event always triggers for regular files.
    FdWrite = 2,
}

/// The state of the file descriptor subscribed to with `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub(crate) struct EventRwFlags {
    /// The peer of this socket has closed or disconnected.
    pub(crate) fd_readwrite_hangup: bool,
}

/// The contents of an `event` when type is `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub(crate) struct EventFdReadwrite {
    /// The number of bytes available for reading or writing.
    pub(crate) nbytes: FileSize,
    /// The state of the file descriptor.
    pub(crate) flags: EventRwFlags,
}

/// An event that occurred.
#[repr(C)]
pub(crate) struct Event {
    /// User-provided value that got attached to `subscription::userdata`.
    pub(crate) userdata: UserData,
    /// If non-zero, an error that occurred while processing the subscription request.
    pub(crate) error: Errno,
    /// The type of event that occured
    pub(crate) type_: EventType,
    /// The contents of the event, if it is an `eventtype::fd_read` or `eventtype::fd_write`. `eventtype::clock` events ignore this field.
    pub(crate) fd_readwrite: EventFdReadwrite,
}

/// Flags determining how to interpret the timestamp provided in `subscription_clock::timeout`.
#[repr(C)]
pub(crate) struct SubClockFlags {
    /// If set, treat the timestamp provided in `subscription_clock::timeout` as an absolute timestamp of clock `subscription_clock::id`. If clear, treat the timestamp provided in `subscription_clock::timeout` relative to the current time value of clock `subscription_clock::id`.
    pub(crate) subscription_clock_abstime: bool,
}

/// The contents of a `subscription` when type is `eventtype::clock`.
#[repr(C)]
pub(crate) struct SubscriptionClock {
    /// The clock against which to compare the timestamp.
    pub(crate) id: ClockID,
    /// The absolute or relative timestamp.
    pub(crate) timeout: TimeStamp,
    /// The amount of time that the implementation may wait additionally to coalesce with other events.
    pub(crate) precision: TimeStamp,
    /// Flags specifying whether the timeout is absolute or relative
    pub(crate) flags: SubClockFlags,
}

/// The contents of a `subscription` when type is type is `eventtype::fd_read` or `eventtype::fd_write`.
#[repr(C)]
pub(crate) struct SubscriptionFdReadwrite {
    /// The file descriptor on which to wait for it to become ready for reading or writing.
    pub(crate) file_descriptor: FD,
}

/// The contents of a `subscription`.
#[repr(u8)]
pub(crate) enum SubscriptionU {
    Clock(SubscriptionClock),
    FdRead(SubscriptionFdReadwrite),
    FdWrite(SubscriptionFdReadwrite),
}

/// Subscription to an event.
#[repr(C)]
pub(crate) struct Subscription {
    /// User-provided value that is attached to the subscription in the implementation and returned through `event::userdata`.
    pub(crate) userdata: UserData,
    /// The type of the event to which to subscribe, and its contents
    pub(crate) u: SubscriptionU,
}

/// Exit code generated by a process when exiting.
pub(crate) type ExitCode = u32;

/// Signal condition.
#[repr(u8)]
pub(crate) enum Signal {
    /// No signal. Note that POSIX has special semantics for `kill(pid, 0)`, so this value is reserved.
    None = 0,
    /// Hangup.
    /// Action: Terminates the process.
    Hup = 1,
    /// Terminate interrupt signal.
    /// Action: Terminates the process.
    Int = 2,
    /// Terminal quit signal.
    /// Action: Terminates the process.
    Quit = 3,
    /// Illegal instruction.
    /// Action: Terminates the process.
    Ill = 4,
    /// Trace/breakpoint trap.
    /// Action: Terminates the process.
    Trap = 5,
    /// Process abort signal.
    /// Action: Terminates the process.
    Abrt = 6,
    /// Access to an undefined portion of a memory object.
    /// Action: Terminates the process.
    Bus = 7,
    /// Erroneous arithmetic operation.
    /// Action: Terminates the process.
    Fpe = 8,
    /// Kill.
    /// Action: Terminates the process.
    Kill = 9,
    /// User-defined signal 1.
    /// Action: Terminates the process.
    Usr1 = 10,
    /// Invalid memory reference.
    /// Action: Terminates the process.
    Segv = 11,
    /// User-defined signal 2.
    /// Action: Terminates the process.
    Usr2 = 12,
    /// Write on a pipe with no one to read it.
    /// Action: Ignored.
    Pipe = 13,
    /// Alarm clock.
    /// Action: Terminates the process.
    Alrm = 14,
    /// Termination signal.
    /// Action: Terminates the process.
    Term = 15,
    /// Child process terminated, stopped, or continued.
    /// Action: Ignored.
    Chld = 16,
    /// Continue executing, if stopped.
    /// Action: Continues executing, if stopped.
    Cont = 17,
    /// Stop executing.
    /// Action: Stops executing.
    Stop = 18,
    /// Terminal stop signal.
    /// Action: Stops executing.
    Tstp = 19,
    /// Background process attempting read.
    /// Action: Stops executing.
    Ttin = 20,
    /// Background process attempting write.
    /// Action: Stops executing.
    Ttou = 21,
    /// High bandwidth data is available at a socket.
    /// Action: Ignored.
    Urg = 22,
    /// CPU time limit exceeded.
    /// Action: Terminates the process.
    Xcpu = 23,
    /// File size limit exceeded.
    /// Action: Terminates the process.
    Xfsz = 24,
    /// Virtual timer expired.
    /// Action: Terminates the process.
    Vtalrm = 25,
    /// Profiling timer expired.
    /// Action: Terminates the process.
    Prof = 26,
    /// Window changed.
    /// Action: Ignored.
    Winch = 27,
    /// I/O possible.
    /// Action: Terminates the process.
    Poll = 28,
    /// Power failure.
    /// Action: Terminates the process.
    Pwr = 29,
    /// Bad system call.
    /// Action: Terminates the process.
    Sys = 30,
}

/// Flags provided to `sock_recv`.
#[repr(C)]
pub(crate) struct RiFlags {
    /// Returns the message without removing it from the socket's receive queue.
    pub(crate) recv_peek: bool,
    /// On byte-stream sockets, block until the full amount of data can be returned.
    pub(crate) recv_waitall: bool,
}

/// Flags returned by `sock_recv`.
#[repr(C)]
pub(crate) struct RoFlags {
    /// Returned by `sock_recv`: Message data has been truncated.
    pub(crate) recv_data_truncated: bool,
}

/// Flags provided to `sock_shutdown`. As there are currently no flags defined, it must be set to zero.
pub(crate) type SiFlags = u16;

/// Which channels on a socket to shut down.
#[repr(u8)]
pub(crate) enum SdFlags {
    /// Disables further receive operations.
    Rd = 1 << 0,
    /// Disables further send operations.
    Wr = 1 << 1,
}

/// Identifier for preopened capabilities.
#[repr(u8)]
pub(crate) enum PreopenType {
    /// A pre-opened directory.
    Dir = 0,
}

/// The contents of a `prestat` when type is `preopen_type::dir`.
#[repr(C)]
pub(crate) struct PreStatDir {
    /// The length of the directory name for use with `fd_prestat_dir_name`.
    pub(crate) pr_name_len: Size,
}

/// Information about a pre-opened directory.
#[repr(u8)]
pub(crate) enum PreStat {
    Dir(PreStatDir),
}

pub(crate) type Size = u32;
pub(crate) type FileSize = u64;
pub(crate) type TimeStamp = u64;

#[repr(u32)]
pub(crate) enum ClockID {
    Realtime = 0,
    Monotonic = 1,
    ProcessCputimeID = 2,
    ThreadCputimeID = 3,
}

/// Error codes returned by functions. Not all of these error codes are returned by the functions provided by this API;
/// some are used in higher-level library layers, and others are provided merely for alignment with POSIX.
#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) enum Errno {
    /// Success
    Success = 0,
    /// Argument list too long
    TooBig = 1,
    /// Permission denied
    Access = 2,
    /// Address already in use
    AddrInUse = 3,
    /// Cannot assign requested address
    AddrNotAvail = 4,
    /// Address family not supported by protocol
    AfNoSupport = 5,
    /// Resource temporarily unavailable
    Again = 6,
    /// Operation already in progress
    Already = 7,
    /// Bad file descriptor
    Badf = 8,
    /// Bad message
    BadMsg = 9,
    /// Device or resource busy
    Busy = 10,
    /// Operation canceled
    Canceled = 11,
    /// No child processes
    Child = 12,
    /// Connection aborted
    ConnAborted = 13,
    /// Connection refused
    ConnRefused = 14,
    /// Connection reset by peer
    ConnReset = 15,
    /// Resource deadlock would occur
    Deadlk = 16,
    /// Destination address required
    DestAddrReq = 17,
    /// Mathematics argument out of domain of function
    Dom = 18,
    /// Reserved
    Dquot = 19,
    /// File exists
    Exist = 20,
    /// Bad address
    Fault = 21,
    /// File too large
    FBig = 22,
    /// Host is unreachable
    HostUnreach = 23,
    /// Identifier removed
    Idrm = 24,
    /// Illegal byte sequence
    Ilseq = 25,
    /// Operation in progress
    InProgress = 26,
    /// Interrupted system call
    Intr = 27,
    /// Invalid argument
    Inval = 28,
    /// I/O error
    Io = 29,
    /// Socket is connected
    IsConn = 30,
    /// Is a directory
    IsDir = 31,
    /// Too many levels of symbolic links
    Loop = 32,
    /// File descriptor value too large
    MFile = 33,
    /// Too many links
    MLink = 34,
    /// Message too large
    MsgSize = 35,
    /// Reserved
    MultiHop = 36,
    /// File name too long
    NameTooLong = 37,
    /// Network is down
    NetDown = 38,
    /// Connection aborted by network
    NetReset = 39,
    /// Network unreachable
    NetUnreach = 40,
    /// Too many open files in system
    NFile = 41,
    /// No buffer space available
    NoBufs = 42,
    /// No such device
    NoDev = 43,
    /// No such file or directory
    NoEnt = 44,
    /// Executable file format error
    NoExec = 45,
    /// No locks available
    NoLck = 46,
    /// Reserved
    NoLink = 47,
    /// Not enough memory
    NoMem = 48,
    /// No message of the desired type
    NoMsg = 49,
    /// Protocol not available
    NoProtoOpt = 50,
    /// No space left on device
    NoSpace = 51,
    /// Function not implemented
    NoSys = 52,
    /// Not connected
    NotConn = 53,
    /// Not a directory
    NotDir = 54,
    /// Directory not empty
    NotEmpty = 55,
    /// State not recoverable
    NotRecoverable = 56,
    /// Not a socket
    NotSock = 57,
    /// Not supported
    NotSup = 58,
    /// Inappropriate I/O control operation
    NotTy = 59,
    /// No such device or address
    Nxio = 60,
    /// Value too large to be stored in data type
    Overflow = 61,
    /// Previous owner died
    OwnerDead = 62,
    /// Operation not permitted
    Perm = 63,
    /// Broken pipe
    Pipe = 64,
    /// Protocol error
    Proto = 65,
    /// Protocol not supported
    ProtoNoSupport = 66,
    /// Protocol wrong type for socket
    Prototype = 67,
    /// Math result not representable
    Range = 68,
    /// Read-only file system
    Rofs = 69,
    /// Streams pipe error
    Spipe = 70,
    /// No such process
    Srch = 71,
    /// Stale file handle
    Stale = 72,
    /// Connection timed out
    TimedOut = 73,
    /// Text file busy
    TxtBsy = 74,
    /// Cross-device link
    Xdev = 75,
    /// Operation not supported on transport endpoint
    NotCapable = 76,
}

impl From<Errno> for ValueRaw {
    fn from(value: Errno) -> Self {
        (value as u32).into()
    }
}

impl From<Errno> for Value {
    fn from(value: Errno) -> Self {
        Value::i32(value as u32)
    }
}

/// File descriptor.
pub(crate) type FD = i32;

bitflags! {
    /// File descriptor rights, determining which actions may be performed.
    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    pub(crate) struct Rights: u64 {
        /// The right to invoke `fd_datasync`. If `path_open` is set, includes the right to invoke `path_open` with `fdflags::dsync`.
        const FdDatasync = 1 << 0;
        /// The right to invoke `fd_read` and `sock_recv`. If `rights::fd_seek` is set, includes the right to invoke `fd_pread`.
        const FdRead = 1 << 1;
        /// The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.
        const FdSeek = 1 << 2;
        /// The right to invoke `fd_fdstat_set_flags`.
        const FdFdstatSetFlags = 1 << 3;
        /// The right to invoke `fd_sync`. If `path_open` is set, includes the right to invoke `path_open` with `fdflags::rsync` and `fdflags::dsync`.
        const FdSync = 1 << 4;
        /// The right to invoke `fd_tell` in such a way that the file offset remains unaltered (i.e., `whence::cur` with offset zero), or to invoke `fd_tell`.
        const FdTell = 1 << 5;
        /// The right to invoke `fd_write` and `sock_send`. If `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.
        const FdWrite = 1 << 6;
        /// The right to invoke `fd_advise`.
        const FdAdvise = 1 << 7;
        /// The right to invoke `fd_allocate`.
        const FdAllocate = 1 << 8;
        /// The right to invoke `path_create_directory`.
        const PathCreateDirectory = 1 << 9;
        /// The right to invoke `path_create_file`. If `path_open` is set, the right to invoke `path_open` with `oflags::creat`.
        const PathCreateFile = 1 << 10;
        /// The right to invoke `path_link` with the file descriptor as the source directory.
        const PathLinkSource = 1 << 11;
        /// The right to invoke `path_link` with the file descriptor as the target directory.
        const PathLinkTarget = 1 << 12;
        /// The right to invoke `path_open`.
        const PathOpen = 1 << 13;
        /// The right to invoke `fd_readdir`.
        const FdReaddir = 1 << 14;
        /// The right to invoke `path_readlink`.
        const PathReadlink = 1 << 15;
        /// The right to invoke `path_rename` with the file descriptor as the source directory.
        const PathRenameSource = 1 << 16;
        /// The right to invoke `path_rename` with the file descriptor as the target directory.
        const PathRenameTarget = 1 << 17;
        /// The right to invoke `path_filestat_get`.
        const PathFilestatGet = 1 << 18;
        /// The right to change a file's size. If `path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.
        const PathFilestatSetSize = 1 << 19;
        /// The right to invoke `path_filestat_set_times`.
        const PathFilestatSetTimes = 1 << 20;
        /// The right to invoke `fd_filestat_get`.
        const FdFilestatGet = 1 << 21;
        /// The right to invoke `fd_filestat_set_size`.
        const FdFilestatSetSize = 1 << 22;
        /// The right to invoke `fd_filestat_set_times`.
        const FdFilestatSetTimes = 1 << 23;
        /// The right to invoke `path_symlink`.
        const PathSymlink = 1 << 24;
        /// The right to invoke `path_remove_directory`.
        const PathRemoveDirectory = 1 << 25;
        /// The right to invoke `path_unlink_file`.
        const PathUnlinkFile = 1 << 26;
        /// If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`. If `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.
        const PollFdReadwrite = 1 << 27;
        /// The right to invoke `sock_shutdown`.
        const SockShutdown = 1 << 28;
        /// The right to invoke `sock_accept`.
        const SockAccept = 1 << 29;
    }
}

impl Rights {
    pub(crate) fn to_libc_mode(self) -> libc::mode_t {
        let mut mode = 0;
        if self.contains(Rights::FdRead) {
            mode |= libc::S_IRUSR;
        }
        if self.contains(Rights::FdWrite) {
            mode |= libc::S_IWUSR;
        }
        mode
    }

    pub(crate) fn to_libc_open_flags(self) -> Result<libc::c_int, Errno> {
        let mut flags = 0;
        if self.contains(Rights::FdRead) && self.contains(Rights::FdWrite) {
            flags |= libc::O_RDWR;
        } else if self.contains(Rights::FdRead) {
            flags |= libc::O_RDONLY;
        } else if self.contains(Rights::FdWrite) {
            flags |= libc::O_WRONLY;
        } else {
            return Err(Errno::Inval);
        }

        if self.contains(Rights::FdSync) {
            flags |= libc::O_SYNC;
        }
        if self.contains(Rights::FdDatasync) {
            flags |= libc::O_DSYNC;
        }

        Ok(flags)
    }
}

/// A region of memory for scatter/gather reads.
#[repr(C)]
pub(crate) struct IOVec {
    /// The address of the buffer to be filled.
    pub(crate) buf: Ptr<u8>,
    /// The length of the buffer to be filled.
    pub(crate) buf_len: Size,
}

/// A region of memory for scatter/gather reads.
#[repr(C)]
pub(crate) struct CIOVec {
    /// The address of the buffer to be filled.
    pub(crate) buf: ConstPtr,
    /// The length of the buffer to be filled.
    pub(crate) buf_len: Size,
}

/// List of scatter/gather vectors.
pub(crate) type IOVecArray = Ptr<IOVec>;

/// List of constant scatter/gather vectors.
pub(crate) type CIOVecArray = Ptr<CIOVec>;

/// Relative offset within a file.
pub(crate) type FileDelta = i64;

/// The position relative to which to set the offset of the file descriptor.
#[repr(u8)]
#[derive(Clone, Copy, Debug)]
pub(crate) enum Whence {
    Set = 0,
    Cur = 1,
    End = 2,
}

/// A reference to the offset of a directory entry.
/// The value 0 signifies the start of the directory.
pub(crate) type DirCookie = u64;

/// The type for the `dirent::d_namlen` field of `dirent` struct.
pub(crate) type DirNamLen = u32;

/// File serial number that is unique within its file system.
pub(crate) type INode = u64;

/// The type of a file descriptor or file.
#[derive(Clone, Copy, PartialEq, Eq)]
pub(crate) enum FileType {
    /// The type of the file descriptor or file is unknown or is different from any of the other types specified.
    Unknown = 0,
    /// The file descriptor or file refers to a block device inode.
    BlockDevice = 1,
    /// The file descriptor or file refers to a character device inode.
    CharacterDevice = 2,
    /// The file descriptor or file refers to a directory inode.
    Directory = 3,
    /// The file descriptor or file refers to a regular file inode.
    RegularFile = 4,
    /// The file descriptor or file refers to a datagram socket.
    SocketDgram = 5,
    /// The file descriptor or file refers to a byte-stream socket.
    SocketStream = 6,
    /// The file refers to a symbolic link inode.
    SymbolicLink = 7,
}

impl From<std::fs::FileType> for FileType {
    fn from(ft: std::fs::FileType) -> Self {
        if ft.is_file() {
            FileType::RegularFile
        } else if ft.is_dir() {
            FileType::Directory
        } else if ft.is_symlink() {
            FileType::SymbolicLink
        } else if ft.is_block_device() {
            FileType::BlockDevice
        } else if ft.is_char_device() {
            FileType::CharacterDevice
        } else {
            FileType::Unknown
        }
    }
}

impl FileType {
    pub(crate) fn from_libc(st_mode: u32) -> Self {
        match st_mode & libc::S_IFMT {
            libc::S_IFBLK => FileType::BlockDevice,
            libc::S_IFCHR => FileType::CharacterDevice,
            libc::S_IFDIR => FileType::Directory,
            libc::S_IFREG => FileType::RegularFile,
            libc::S_IFSOCK => FileType::SocketStream,
            libc::S_IFLNK => FileType::SymbolicLink,
            _ => FileType::Unknown,
        }
    }
}

/// A directory entry.
#[repr(C)]
pub(crate) struct DirEnt {
    /// The offset of the next directory entry stored in the directory.
    pub(crate) d_next: DirCookie,
    /// The serial number of the file in the directory.
    pub(crate) d_ino: INode,
    /// The length of the name of the directory entry.
    pub(crate) d_namelen: DirNamLen,
    /// The type of the file.
    pub(crate) d_type: FileType,
}

/// File or memory access pattern advisory information.
#[repr(u8)]
pub(crate) enum Advice {
    /// The application has no further expectation about the access pattern of the specified data.
    Normal = 0,
    /// The application expects to access the specified data sequentially from lower offsets to higher offsets.
    Sequential = 1,
    /// The application expects to access the specified data in a random order.
    Random = 2,
    /// The application expects to access the specified data in the near future.
    WillNeed = 3,
    /// The application expects that it will not access the specified data in the near future.
    DontNeed = 4,
    /// The application expects to access the specified data once and then not reuse it thereafter.
    NoReuse = 5,
}

bitflags! {
    /// File descriptor flags.
    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
    pub(crate) struct FdFlags: u16 {
        /// Append mode: Data written to the file is always appended to the file's end.
        const Append = 1 << 0;
        /// Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.
        const DSync = 1 << 1;
        /// Non-blocking mode.
        const Nonblock = 1 << 2;
        /// Synchronized read I/O operations.
        const RSync = 1 << 3;
        /// Write according to synchronized I/O file integrity completion. In addition to synchronizing the data stored in the file,
        /// the implementation may also synchronously update the file's metadata.
        const Sync = 1 << 4;
    }
}

impl FdFlags {
    pub(crate) fn to_libc_open_flags(self) -> libc::c_int {
        let mut flags = 0;
        if self.contains(FdFlags::Append) {
            flags |= libc::O_APPEND;
        }
        if self.contains(FdFlags::RSync) {
            flags |= libc::O_RSYNC;
        }
        flags
    }
}

/// File descriptor attributes.
#[repr(C)]
#[derive(Clone, Copy)]
pub(crate) struct FdStat {
    /// File type.
    pub(crate) fs_filetype: FileType,
    /// File descriptor flags.
    pub(crate) fs_flags: FdFlags,
    /// Rights that apply to this file descriptor.
    pub(crate) fs_rights_base: Rights,
    /// Maximum set of rights that may be installed on new paths relative to this file descriptor.
    pub(crate) fs_rights_inheriting: Rights,
}

/// Identifier for a device containing a file system.
pub(crate) type Device = u64;

bitflags! {
    /// Which file time attributes to adjust.
    pub(crate) struct FstFlags: u16 {
        /// Adjust the last data access timestamp to the value stored in `filestat::atim`.
        const Atim = 1 << 0;
        /// Adjust the last data access timestamp to the time of clock `clockid::realtime`.
        const AtimNow = 1 << 1;
        /// Adjust the last data modification timestamp to the value stored in `filestat::mtim`.
        const Mtim = 1 << 2;
        /// Adjust the last data modification timestamp to the time of clock `clockid::realtime`.
        const MtimNow = 1 << 3;
    }
}

bitflags! {
    /// Flags determining the method of how paths are resolved.
    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
    pub(crate) struct LookupFlags: u32 {
        /// As long as the resolved path corresponds to a symbolic link, it is expanded.
        const SymlinkFollow = 1 << 0;
    }
}

impl LookupFlags {
    pub(crate) fn to_libc(self) -> libc::c_int {
        let mut flags: i32 = 0;
        if self.contains(LookupFlags::SymlinkFollow) {
            flags |= libc::AT_SYMLINK_FOLLOW;
        }
        flags
    }
}

bitflags! {
    /// Open flags used by `path_open`.
    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
    pub(crate) struct OpenFlags: u16 {
        /// Create the file if it does not exist.
        const Creat = 1 << 0;
        /// Fail if not a directory.
        const Directory = 1 << 1;
        /// Fail if file already exists.
        const Excl = 1 << 2;
        /// Truncate file to size 0.
        const Trunc = 1 << 3;
    }
}

impl OpenFlags {
    pub(crate) fn to_libc(self) -> libc::c_int {
        let mut flags = 0;
        if self.contains(OpenFlags::Creat) {
            flags |= libc::O_CREAT;
        }
        if self.contains(OpenFlags::Directory) {
            flags |= libc::O_DIRECTORY;
        }
        if self.contains(OpenFlags::Excl) {
            flags |= libc::O_EXCL;
        }
        if self.contains(OpenFlags::Trunc) {
            flags |= libc::O_TRUNC;
        }
        flags
    }
}

/// Number of hard links to an inode.
pub(crate) type LinkCount = u64;

/// File attributes.
#[repr(C)]
pub(crate) struct FileStat {
    /// Device ID of device containing the file.
    pub(crate) dev: Device,
    /// File serial number.
    pub(crate) ino: INode,
    /// File type.
    pub(crate) filetype: FileType,
    /// Number of hard links to the file.
    pub(crate) nlink: LinkCount,
    /// For resizable files, the file size in bytes.
    /// For symbolic links, the length in bytes of the pathname contained in the symbolic link.
    pub(crate) size: FileSize,
    /// Last data access timestamp.
    pub(crate) atim: TimeStamp,
    /// Last data modification timestamp.
    pub(crate) mtim: TimeStamp,
    /// Last file status change timestamp.
    pub(crate) ctim: TimeStamp,
}

/// User-provided value that may be attached to objects that is retained when extracted from the implementation.
pub(crate) type UserData = u64;
